<h2 id="partie-controleur">Partie contrôleur</h2><p>NodeAtlas ne se contente pas uniquement de faciliter la génération de page web en fonction de variables dans les fichiers de variation. NodeAtlas vous permet également d'intéragir avec le contenu des fichiers de variations ou avec le DOM généré à partir de ceux-ci en fonction :</p><ul>
<li>des paramètres dans la partie query de l'URL (GET),</li>
<li>des paramètres dans le corps de la requête (POST)</li>
</ul><p>mais également, couplé à des fonctionnalités natives de Node.js ou de npm, en fonction :</p><ul>
<li>d'informations dans des fichiers,</li>
<li>d'informations dans des bases de données,</li>
<li>d'informations dans des sessions utilisateurs actives,</li>
<li>d'informations fournit par échanges WebSockets et</li>
<li>de faire bien plus encore !</li>
</ul><h3 id="cycle-de-vie">Cycle de vie</h3><p>Le cycle de vie de NodeAtlas est le suivant. D'abord, les ressources se chargent, le serveur démarre, les routes s'initialisent et tout est opérationnel. Puis, à chaque requête HTTP entrante, une réponse est générée. Vous pouvez intervenir grâce à différents points d'ancrage pendant le démarrage, et pendant la création d'une page.</p><p>Voici à quoi peut ressembler un <code>webconfig.json</code> permettant d'atteindre tous les points d'ancrage du cycle de vie d'une page.</p><pre><code class="language-json">{
    "controllersRelativePath": "controllers",
    "controller": "common.js",
    "routes": {
        "/": {
            "view": "index.htm",
            "controller": "index.json"
        }
    }
}</code></pre><p><em>Note : si</em> <code>controllersRelativePath</code> <em>n'est pas présent dans <code>webconfig.json</code>, par défaut le dossier des contrôleurs est bien</em> <code>controllers</code>. <code>controllersRelativePath</code> <em>est donc utile seulement pour changer le nom / chemin du répertoire.</em></p><p>et voici le détail des endroits ou vous pouvez intervenir pendant :</p><h4 id="le-lancement-du-serveur">Le lancement du serveur</h4><pre><code class="language-txt">┌─[Chargement des modules Node.js]
┊
├─[Chargement des variables d'initialisation]
┊
├─[Chargement des modules npm]
┊
├─[Prise en compte des commandes et de la langue du CLI]
┊
├─[Prise en compte des options de l'API]
┊
└─[Chargement de la langue du CLI]
  ┊
  ├─[Chargement des variables globales]
  ┊
  ├─[Prise en compte des instructions du webconfig]
  ┊
  └─[Chargement du contrôleur commun]
    ┊  _________________________________________
    ├─{Point d'ancrage : &lt;controller&gt;.setModules}
    ┊  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    ├─[Initialisation du serveur]
    ┊  __________________________________________
    ├─{Point d'ancrage : &lt;controller&gt;.setSessions}
    ┊  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    ├─[Initialisation des sessions]
    ┊
    ├─[Initialisation des sockets]
    ┊ ┊  _________________________________________
    ┊ ├─{Point d'ancrage : &lt;controller&gt;.setSockets}_______
    ┊ └─{Point d'ancrage : routes[&lt;controller&gt;].setSockets}
    ┊    ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    ┊  ________________________________________________
    ├─{Point d'ancrage : &lt;controller&gt;.setConfigurations}
    ┊  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    └─[Démarrage du serveur]
      ┊
      ├─[Initialisation du moteur de template]
      ┊  ________________________________________
      ├─{Point d'ancrage : &lt;controller&gt;.setRoutes}
      ┊  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
      └─[Initialisation des routes]
        ┊
        ∞</code></pre><h4 id="le-traitement-des-requêtes-de-chaque-route">Le traitement des requêtes de chaque route</h4><pre><code class="language-txt">∞
┊
└─[Traitement d'une requête]
  ┊
  └─[Chargement du contrôleur spécifique]
    ┊  _______________________________________________
    ├─{Point d'ancrage : &lt;controller&gt;.changeVariations}_______
    ├─{Point d'ancrage : routes[&lt;controller&gt;].changeVariations}
    ┊  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
    └─[Compilation du moteur de template]
      ┊  ________________________________________
      ├─{Point d'ancrage : &lt;controller&gt;.changeDom}_______
      ├─{Point d'ancrage : routes[&lt;controller&gt;].changeDom}
      ┊  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾
      └─[Envoi de la réponse]
        ┊
        ∞</code></pre><h3 id="point-d-ancrage-changevariations">Point d'ancrage <code>changeVariations</code></h3><p>Pour intercepter les variations, vous pouvez soit utiliser le contrôleur commun pour tout le site et / ou également le contrôleur par page.</p><p><code>changeVariations(next, locals, request, response)</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
<li>En premier argument la fonction de rappel <code>next()</code>.</li>
<li>En deuxième argument l'objet <code>locals</code> contenant entre autre la variation <code>locals.common</code> pour accéder aux variations communes et la variation <code>locals.specific</code> pour accéder aux variations spécifiques.</li>
<li>En troisième argument l'objet <code>request</code> pour cette page.</li>
<li>En quatrième argument l'objet <code>response</code> pour cette page.</li>
</ul><p>Voici un exemple utilisant les deux points d'entrée, d'abord la commune à plusieurs pages, puis celle de chaque page :</p><pre><code class="language-json">{
    "urlRelativeSubPath": "exemple",
    "controller": "common.js",
    "variation": "common.json",
    "routes": {
        "/": {
            "view": "index.htm",
            "variation": "index.json",
            "controller": "index.js"
        }
    }
}</code></pre><p>avec cet ensemble de fichier :</p><pre><code class="language-txt">├─ variations/
│  ├─ common.json
│  └─ index.json
├─ controllers/
│  ├─ common.js
│  └─ index.js
├─ views/
│  ├─ partials/
│  │  ├─ head.htm
│  │  └─ foot.htm
│  └─ index.htm
└─ webconfig.json</code></pre><p>En demandant la page <code>http://localhost/exemple/?title=MachinisteWeb</code> en POST avec une variable <code>example=Ceci+est+un+test</code> dans le corps de requête, les fichiers suivants (entre autre) seront utilisés :</p><p><em>variations/common.json</em></p><pre><code class="language-json">{
    "titleWebsite": "Titre du site"
}</code></pre><p><em>variations/index.json</em></p><pre><code class="language-json">{
    "titlePage": "Bienvenue",
    "content": "&lt;p&gt;C'est la page d'accueil.&lt;/p&gt;"
}</code></pre><p><em>views/index.htm</em></p><pre><code class="language-html">    &lt;?- include("partials/head.htm") ?&gt;

    &lt;div class="title"&gt;&lt;?- common.titleWebsite ?&gt;&lt;/div&gt;

    &lt;div&gt;
        &lt;h1&gt;&lt;?- specific.titlePage ?&gt;&lt;/h1&gt;
        &lt;?- specific.content ?&gt;
    &lt;/div&gt;

    &lt;?- include("partials/foot.htm") ?&gt;</code></pre><p><em>controllers/common.js</em></p><pre><code class="language-js">// On intervient avant que les variables soient injectées dans le moteur de template.
// Ce code sera exécuté pour toute requête HTTP, toutes pages confondues.
exports.changeVariations = function (next, locals, request, response) {

    // Ici on modifie les variables de `locals`.

    console.log(locals.common.titleWebsite); // `"Titre du site"`
    console.log(locals.specific.titlePage); // `"Bienvenue"`
    console.log(locals.specific.content); // `"C'est la page d'accueil."`

    console.log("urlRootPath", locals.urlRootPath); // "http://localhost"
    console.log("urlSubPath", locals.urlSubPath); // `"/exemple"`
    console.log("urlBasePath", locals.urlBasePath); // `"http://localhost/exemple"`
    console.log("urlFilePath", locals.urlFilePath); // `"/"`
    console.log("urlQueryPath", locals.urlQueryPath); // `"?title=MachinisteWeb"`
    console.log("urlPath", locals.urlPath); // `"http://localhost/example/?title=MachinisteWeb"`

    if (request.query["title"]) {
        locals.specific.titlePage = locals.specific.titlePage + " " + request.query.title;
    }
    if (request.body["example"]) {
        locals.specific.content = request.body.example;
    }

    console.log(locals.common.titleWebsite); // `"Titre du site"`
    console.log(locals.specific.titlePage); // `"Bienvenue MachinisteWeb"`
    console.log(locals.specific.content); // `"Ceci est un test"`

    // On passe à la suite.
    next();
};</code></pre><p><em>controllers/index.js</em></p><pre><code class="language-js">// On intervient avant que les variables soient injectées dans le moteur de template.
// Ce code sera exécuté uniquement lors de la demande de la page `/`.
exports.changeVariations = function (next, locals, request, response) {

    // Ici on modifie les variables de `locals`.

    console.log(locals.common.titleWebsite); // `"Titre du site"`
    console.log(locals.specific.titlePage); // `"Bienvenue MachinisteWeb"`
    console.log(locals.specific.content); // `"Ceci est un test"`

    locals.common.titleWebsite = `"C'est l'accueil, c'est tout."`;
    locals.specific.content = `"C'est l'accueil, c'est tout."`;

    console.log(locals.common.titleWebsite); // `"C'est l'accueil, c'est tout."`
    console.log(locals.specific.titlePage); // `"Bienvenue MachinisteWeb"`
    console.log(locals.specific.content); // `"C'est l'accueil, c'est tout."`

    // On passe à la suite.
    next();
};</code></pre><p>ce qui produit la sortie suivante :</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;C'est l'accueil, c'est tout.&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="title"&gt;C'est l'accueil, c'est tout.&lt;/div&gt;
        &lt;div&gt;
            &lt;h1&gt;Bienvenue MachinisteWeb&lt;/h1&gt;
            C'est l'accueil, c'est tout.
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Si vous décidez de désabonner la variation spécifique avec le webconfig suivant :</p><pre><code class="language-json">{
    "controller": "common.js",
    "variation": "common.json",
    "routes": {
        "/": {
            "view": "index.htm",
            "variation": "index.json"
        }
    }
}</code></pre><p>alors la sortie sera :</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Titre du site&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="title"&gt;Titre du site&lt;/div&gt;
        &lt;div&gt;
            &lt;h1&gt;Bienvenue MachinisteWeb&lt;/h1&gt;
            Ceci est un test
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><h3 id="point-d-ancrage-changedom">Point d'ancrage <code>changeDom</code></h3><p>Pour intercepter le DOM avant qu'il ne soit renvoyé, vous pouvez soit utiliser le contrôleur commun pour tout le site et / ou également le contrôleur par page.</p><p><code>changeDom(next, locals, request, response)</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
<li>En premier argument la fonction de retour <code>next([dom])</code> acceptant optionellement en premier argument un objet' <code>dom</code> utilisée pour manipuler le DOM virtuel.</li>
<li>En deuxième argument l'objet <code>locals</code> contenant entre autre la chaine de caractères <code>locals.dom</code> contenant la réponse ou la fonction <code>locals.virtualDom()</code> générant un Dom virtuel manipulable.</li>
<li>En troisième argument l'objet <code>request</code> pour cette page.</li>
<li>En quatrième argument l'objet <code>response</code> pour cette page.</li>
</ul><p>Voici un exemple utilisant les deux points d'entrée, d'abord la commune à plusieurs pages, puis celle de chaque page :</p><pre><code class="language-json">{
    "controller": "common.js",
    "variation": "common.json",
    "routes": {
        "/": {
            "view": "index.htm",
            "variation": "index.json",
            "controller": "index.js"
        }
    }
}</code></pre><p>avec cet ensemble de fichier :</p><pre><code class="language-txt">├─ variations/
│  ├─ common.json
│  └─ index.json
├─ controllers/
│  ├─ common.js
│  └─ index.js
├─ views/
│  └─ index.htm
└─ webconfig.json</code></pre><p>En demandant la page <code>http://localhost/</code> les fichiers suivants (entre autre) seront utilisés :</p><p><em>variations/common.json</em></p><pre><code class="language-json">{
    "titleWebsite": "Titre du site"
}</code></pre><p><em>variations/index.json</em></p><pre><code class="language-json">{
    "titlePage": "Bienvenue",
    "content": "&lt;p&gt;C'est la page d'accueil.&lt;/p&gt;"
}</code></pre><p><em>views/index.htm</em></p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;&lt;?- common.titleWebsite ?&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="title"&gt;&lt;?- common.titleWebsite ?&gt;&lt;/div&gt;
        &lt;div&gt;
            &lt;h1&gt;&lt;?- specific.titlePage ?&gt;&lt;/h1&gt;
            &lt;?- specific.content ?&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p><em>controllers/common.js</em></p><pre><code class="language-js">// On intervient avant que le DOM ne soit renvoyé au client.
// Ce code sera exécuté pour toute requête HTTP, toutes pages confondues.
exports.changeDom = function (next, locals, request, response) {
    // Transformer la chaîne HTML en DOM virtuel.
    var dom = locals.virtualDom();

    // Après tous les h1 de la sortie HTML de `dom`...
    Array.prototype.forEach.call(dom.window.document.getElementsByTagName("h1"), function (h1) {

        // ...on crée une div,
        var div = dom.window.document.createElement('div');

        // ... on injecte le contenu du h1 dans la div...
        div.innerHTML = h1.innerHTML;
        h1.parentNode.insertBefore(div, h1.nextElementSibling);

        // ...et supprime le h1.
        h1.parentNode.removeChild(h1);
    });

    // On retourne les modifications pour qu'elles redeviennent une chaîne de caractères HTML.
    next(dom);
};</code></pre><p><em>controllers/index.js</em></p><pre><code class="language-js">// On intervient avant que le DOM ne soit renvoyé au client.
// Ce code sera exécuté uniquement lors de la demande de la page `/`.
exports.changeDom = function (next, locals, request, response) {
    var NA = this,
        jsdom = NA.modules.jsdom, // Récupération de `jsdom` pour parcourir le DOM virtuel.
        dom = new jsdom.JSDOM(locals.dom); // On charge les données pour les manipuler comme un DOM.

    // On modifie le contenu du nœud avec la classe `.title`.
    dom.window.document.getElementsByClassName("title")[0].textContent = "Modification de Contenu";

    // On recrée une nouvelle sortie HTML avec nos modifications.
    locals.dom = dom.serialize();

    // On passe à la suite.
    next();
};</code></pre><p>ce qui produit la sortie suivante :</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Titre du site&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="title"&gt;Modification de Contenu&lt;/div&gt;
        &lt;div&gt;
            &lt;div&gt;Bienvenue&lt;/div&gt;
            &lt;p&gt;C'est la page d'accueil.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><h3 id="point-d-ancrage-setsockets">Point d'ancrage <code>setSockets</code></h3><p>Pour maintenir une connexion temps réel entre votre partie cliente et serveur à travers toutes les pages ouvertes sur tous les navigateurs de tous les ordinateurs sur le web, vous aller pouvoir définir vos WebSockets ici <a href="partie-controleur.html#echanges-websockets">Plus de détail dans la partie Socket.IO</a>.</p><p><code>setSockets()</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
</ul><p>Voici un exemple utilisant les deux points d'entrée, d'abord le commun à plusieurs pages, puis celui pour chaque page :</p><pre><code class="language-json">{
    "socketClientFile": "/node-atlas/socket.io.js",
    "socketServerOptions": { "transports": ["polling", "websocket"] },
    "controller": "common.js",
    "routes": {
        "/": {
            "view": "index.htm",
            "controller": "index.js"
        }
    }
}</code></pre><p>avec cet ensemble de fichier :</p><pre><code class="language-txt">├─ assets/
│  └─ javascripts/
│     └─ index.js
├─ controllers/
│  ├─ common.js
│  ├─ index.js
│  └─ test.js
├─ views/
│  └─ index.htm
└─ webconfig.json</code></pre><p>En demandant la page <code>http://localhost/</code> les fichiers suivants (entre autre) seront utilisés :</p><p><em>views/index.htm</em></p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Exemple Websocket&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="layout"&gt;
            &lt;div class="content"&gt;&lt;/div&gt;
            &lt;div class="field"&gt;Tape du texte : &lt;input class="input" type="text"&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;script type="text/javascript" src="socket.io/socket.io.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="node-atlas/socket.io.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/test.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/index.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p><em>Note : si</em> <code>socketClientFile</code> <em>et</em> <code>socketServerOptions</code> <em>ne sont pas présent dans <code>webconfig.json</code>, par défaut le fichier client et les options serveurs pour configurer les sockets sont bien</em> <code>/node-atlas/socket.io.js</code> <em>et</em> <code>{ transports: ['polling', 'websocket'] }</code>. <em>Il sont donc utiles seulement pour changer le chemin du fichier ou les transports des sockets permis. Si vous mettez <code>socketClientFile</code> à <code>false</code>, le fichier client ne sera pas accessible.</em></p><p><em>assets/javascripts/test.js</em></p><pre><code class="language-js">(function (expose, factory) {
    if (typeof module !== 'undefined' &amp;&amp; module.exports) {
        module.exports = factory;
    } else {
        expose.Test = factory;
    }
}(this, function () {
    if (NA.isClient) {
        console.log("Client");
    } else {
        console.log("Serveur");
    }
}));</code></pre><p><em>controllers/common.js</em></p><pre><code class="language-js">// On référence les actions de réponse et d'envoi globaux côté serveur.
// Ce code sera exécuté pour toute entrée WebSocket entrante.
exports.setSockets = function () {
    var NA = this,
        io = NA.io;

    io.on('connection', function (socket) {
        console.log("Un onglet est ouvert.");
        socket.on('disconnect', function () {
            console.log("Un onglet est fermé.");
        });
    });
};</code></pre><p><em>controllers/index.js</em></p><pre><code class="language-js">// On référence les actions de réponse et d'envoi globaux côté serveur.
// Ce code sera exécuté pour toute entrée WebSocket entrante.
exports.setSockets = function () {
    var NA = this,
        path = NA.modules.path,
        io = NA.io;

    require(path.join(NA.serverPath, NA.webconfig.assetsRelativePath, "javascripts/test.js"))(); // affiche `Serveur`

    // Attendre un lien valide entre client et serveur
    io.sockets.on("connection", function (socket) {

        // Quelqu'un nous informe que le texte à changé.
        socket.on("update-text", function (data) {

            // On informe les autres que le texte à changé.
            io.sockets.emit("update-text", data);
        });
    });
};</code></pre><p><em>assets/javascripts/index.js</em></p><pre><code class="language-js">var content = document.getElementsByClassName("content")[0],
    input = document.getElementsByClassName("input")[0];

Test(); // affiche `Client`

// On alerte les autres de nos modifications.
input.addEventListener("keyup", function () {
    content.innerHTML = input.value;
    NA.socket.emit("update-text", {
        text: input.value
    });
});

// On récupère les modifications des autres.
NA.socket.on("update-text", function (data) {
    content.innerHTML = data.text;
    input.value = data.text;
});</code></pre><p>Vous pourrez, en ouvrant divers navigateurs, et divers onglets, constater que tout est bien mis à jour chez tout le monde. Chaque nouvel onglet ouvert affiche sur le serveur le message de connexion, et chaque onglet fermé, le message de deconnexion sur la console serveur.</p><p><em>Note : vous pouvez changer le fichier <code>node-atlas/socket.io.js</code> par un fichier fournis par vous-même pour changer la variable <code>optionsSocket</code>. Vous pouvez aussi changer la valeur de <code>NA.optionsSocket</code> côté client (avant l'insertion de <code>node-atlas/socket.io.js</code>) avec un objet d'options personnalisées.</em></p><h3 id="point-d-ancrage-setmodules">Point d'ancrage <code>setModules</code></h3><p>Pour charger d'autres modules qui ne sont pas fournis avec NodeAtlas vous pouvez utiliser le contrôleur commun pour tout le site afin de les charger une seule fois et de les rendres disponible dans tous vos contrôleurs.</p><p><code>setModules()</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
</ul><p>Voici un exemple utilisant un module externe à NodeAtlas :</p><pre><code class="language-json">{
    "controller": "common.js",
    "routes": {
        "/": {
            "view": "index.htm",
            "controller": "index.js"
        }
    }
}</code></pre><p>avec cet ensemble de fichier :</p><pre><code class="language-txt">├─ controllers/
│  ├─ common.js
│  └─ index.js
├─ views/
│  └─ index.htm
└─ webconfig.json</code></pre><p>En demandant la page <code>http://localhost/</code> les fichiers suivants (entre autre) seront utilisés :</p><p><em>views/index.htm</em></p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Test d'un module&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="title"&gt;Test d'un module&lt;/div&gt;
        &lt;div&gt;
            &lt;h1&gt;Test d'un module&lt;/h1&gt;
            &lt;?- example ?&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p><em>controllers/common.js</em></p><pre><code class="language-js">// On intervient avant que la phase de chargement des modules ne soit achevée.
// Ce code sera exécuté au lancement de NodeAtlas.
exports.setModules = function () {
    // Récupérer l'instance NodeAtlas du moteur.
    var NA = this;

    // Associations de chaque module pour y avoir accès partout.
    NA.modules.marked = require('marked');
};</code></pre><p><em>controllers/index.js</em></p><pre><code class="language-js">// On intervient avant que les variables soient injectées dans le système de template.
// Ce code sera exécuté uniquement lors de la demande de la page `/`.
exports.changeVariations = function (next, locals) {
    // Utiliser l'instance NodeAtlas depuis le moteur.
    var NA = this,
        marked = NA.modules.marked;

    locals.example = marked("J'utilise __markdown__.");

    // On passe à la suite.
    next();
};</code></pre><p>ce qui produit la sortie suivante :</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Test d'un module&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="title"&gt;Test d'un module&lt;/div&gt;
        &lt;div&gt;
            &lt;h1&gt;Test d'un module&lt;/h1&gt;
            &lt;p&gt;J'utilise &lt;strong&gt;markdown&lt;/strong&gt;.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><h3 id="point-d-ancrage-setconfigurations">Point d'ancrage <code>setConfigurations</code></h3><p>Pour configurer le serveur web de NodeAtlas (<a href="http://expressjs.com/">Express</a>) vous pouvez utiliser le contrôleur commun pour tout le site afin de faire vos modifications avant le démarrage du serveur.</p><p><code>setConfigurations(next)</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
<li>En premier argument la fonction de rappel <code>next()</code>.</li>
</ul><p>Voici un exemple utilisant un middleware pour <a href="http://expressjs.com/">Express</a> :</p><pre><code class="language-json">{
    "controller": "common.js",
    "routes": {
        "/": {
            "view": "index.htm",
            "controller": "index.js"
        }
    }
}</code></pre><p>avec cet ensemble de fichier :</p><pre><code class="language-txt">├─ controllers/
│  ├─ common.js
│  └─ index.js
├─ views/
│  └─ index.htm
└─ webconfig.json</code></pre><p>En demandant la page <code>http://localhost/</code> les fichiers suivants (entre autre) seront utilisés :</p><p><em>views/index.htm</em></p><pre><code class="language-html">&lt;?- content ?&gt;</code></pre><p><em>controllers/common.js</em></p><pre><code class="language-js">// On intervient au niveau du serveur avant que celui-ci ne soit démarré.
// Ce code sera exécuté au lancement de NodeAtlas.
exports.setConfigurations = function (next) {
    // Récupérer l'instance NodeAtlas du moteur.
    var NA = this;

    // Middleware utilisé lors de chaque requête.
    NA.express.use(function (request, response, next) {
        response.setHeader("X-Frame-Options", "ALLOW-FROM https://www.lesieur.name/");
        next();
    });

    // On passe à la suite.
    next();
};</code></pre><p><em>controllers/index.js</em></p><pre><code class="language-js">// On intervient avant que les variables soient injectées dans le moteur de template.
// Ce code sera exécuté uniquement lors de la demande de la page `/`.
exports.changeVariations = function (next, locals) {

    // On prépare le fichier pour un affichage JSON.
    locals.routeParameters.headers = {
        "Content-Type": "application/json; charset=utf-8"
    };
    locals.content = JSON.stringify(locals, null, "    ");

    // On passe à la suite.
    next();
};</code></pre><p>ce qui produit la sortie suivante :</p><pre><code class="language-html">{
    "urlRootPath": "http://localhost",
    "urlSubPath": "",
    "urlBasePath": "http://localhost",
    "urlFilePath": "/",
    "urlQueryPath": "",
    "urlPath": "http://localhost/",
    "params": {},
    "query": {},
    "body": {},
    "routeParameters": { /* ... */ },
    "route": "/",
    "webconfig": { /* ... */ }
}</code></pre><h3 id="point-d-ancrage-setsessions">Point d'ancrage <code>setSessions</code></h3><p>Pour configurer les sessions client-serveur de NodeAtlas vous pouvez utiliser le contrôleur commun pour tout le site afin de définir vos sessions avant le démarrage du serveur. Voici un exemple de gestion de session avec <a href="http://redis.io/">Redis</a>.</p><p><code>setSessions(next)</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
<li>En premier paramètre la fonction de retour <code>next()</code>.</li>
</ul><p>Voici l'ensemble de fichier suivant :</p><pre><code class="language-txt">├─ controllers/
│  └─ common.js
├─ views/
│  └─ index.htm
├─ variations/
│  ├─ common.json
│  └─ index.json
└─ webconfig.json</code></pre><p>Avec le <code>webconfig.json</code> :</p><pre><code class="language-json">{
    "controller": "common.js",
    "routes": {
        "/": {
            "view": "index.htm"
        }
    }
}</code></pre><p>Et avec le fichier <code>common.js</code> contenant par exemple :</p><pre><code class="language-js">// On intervient avant que la phase de chargement des modules ne soit achevée.
// Ce code sera exécuté au lancement de NodeAtlas.
exports.setModules = function () {
    // Récupérer l'instance NodeAtlas du moteur.
    var NA = this;

    // Associations de chaque module pour y avoir accès partout.
    NA.modules.RedisStore = require('connect-redis');
};

// On intervient au niveau du serveur pendant la configuration des sessions.
// Ce code sera exécuté au lancement de NodeAtlas.
exports.setSessions = function (next) {
    var NA = this,
        session = NA.modules.session,
        RedisStore = NA.modules.RedisStore(session);

    // On remplace la session par default.
    NA.sessionStore = new RedisStore();

    // On redonne la main à NodeAtlas pour la suite.
    next();
};</code></pre><h3 id="point-d-ancrage-setroutes">Point d'ancrage <code>setRoutes</code></h3><p>Pour configurer les routes de NodeAtlas dynamiquement vous pouvez utiliser le contrôleur commun pour tout le site afin de les charger une seule fois et de les rendres disponible dans tous vos contrôleurs.</p><p><code>setRoutes(next)</code> est une fonction a <code>exports</code> et fournissant :</p><ul>
<li>L'objet <code>NA</code> en tant que <code>this</code>.</li>
<li>En premier argument la fonction de rappel <code>next()</code>.</li>
</ul><p>Voici l'ensemble de fichier suivant :</p><pre><code class="language-txt">├─ controllers/
│  └─ common.js
├─ views/
│  ├─ content.htm
│  └─ index.htm
├─ variations/
│  └─ common.json
└─ webconfig.json</code></pre><p>Avec le <code>webconfig.json</code> :</p><pre><code class="language-json">{
    "controller": "common.js",
    "variation": "common.json",
    "routes": {
        "/index.html": {
            "view": "index.htm"
        }
    }
}</code></pre><p>et avec le fichier <code>common.js</code> contenant par exemple :</p><pre><code class="language-js">// On intervient au niveau des routes pendant qu'elles sont ajoutées.
// Ce code sera exécuté au lancement de NodeAtlas.
exports.setRoutes = function (next) {

    // On récupère l'instance de NodeAtlas en cours.
    var NA = this,

        // Et nous récupérons les routes en provenance du webconfig...
        route = NA.webconfig.routes;

    // ...pour ajouter la route "/content.html" à la liste de nos routes.
    route["/content.html"] = {
        "view": "content.htm"
    };

    // On redonne la main à NodeAtlas pour la suite.
    next();
};</code></pre><h3 id="echanges-websockets">Échanges WebSockets</h3><p>Afin de conserver une liaison ouverte entre la partie cliente et la partie serveur de vos applications, NodeAtlas utilise <a href="http://socket.io/">Socket.IO</a> dont vous trouverez plus de détail sur le site officiel.</p><p>Grâce à cela, vous pourrez changer des informations en temps réel sur votre page, mais également sur toutes les autres pages ouvertes à travers tous les autres navigateurs.</p><p>Avec l'ensemble de fichier suivant :</p><pre><code class="language-txt">├─ assets/
│  └─ javascripts/
│     └─ index.js
├─ controllers/
│  └─ index.js
├─ variations/
│  ├─ common.json
│  └─ index.json
├─ views/
│  ├─ partials/
│  │  └─ index.htm
│  └─ index.htm
└─ webconfig.json</code></pre><p>Contenant le <code>webconfig.json</code> suivant :</p><pre><code class="language-json">{
    "variation": "common.json",
    "routes": {
        "/": {
            "view": "index.htm",
            "variation": "index.json",
            "controller": "index.js"
        }
    }
}</code></pre><p>et contenant les fichiers de template suivant :</p><p><em>views/partials/index.htm</em></p><pre><code class="language-html">        &lt;div class="title"&gt;&lt;?- common.titleWebsite ?&gt;&lt;/div&gt;
        &lt;div&gt;
            &lt;h1&gt;&lt;?- specific.titlePage ?&gt;&lt;/h1&gt;
            &lt;?- specific.content ?&gt;
            &lt;div&gt;&lt;?- new Date() ?&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;button&gt;Mettre à jour&lt;/button&gt;</code></pre><p><em>Note : chaque clique sur <code>button</code> raffraichira le contenu de <code>views/partials/index.htm</code>.</em></p><p><em>views/index.htm</em></p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="fr-fr"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;&lt;?- common.titleWebsite ?&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="layout"&gt;
            &lt;?- include('partials/index.htm') ?&gt;
        &lt;/div&gt;
        &lt;script type="text/javascript" src="socket.io/socket.io.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="node-atlas/socket.io.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/index.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre><p><em>Note : on construit ici la page d'accueil <code>/</code>.</em></p><p>ainsi que les fichiers de variations suivant :</p><p><em>variations/common.json</em></p><pre><code class="language-json">{
    "titleWebsite": "Exemple Socket.IO"
}</code></pre><p><em>variations/index.json</em></p><pre><code class="language-json">{
    "titlePage": "Date",
    "content": "&lt;p&gt;La date actuelle est :&lt;/p&gt;"
}</code></pre><p>Jusque là, rien d'inhabituel et tout fonctionnerait sans partie contrôleur. Mais nous allons mettre en place la communication via Socket.IO côté serveur puis côté client.</p><p>Côté serveur, nous utiliserons le contrôleur commun suivant :</p><p><em>controllers/index.js</em></p><pre><code class="language-js">// Intégralité des actions WebSocket possibles avec `setSockets`.
exports.setSockets = function () {
    var NA = this,
        io = NA.io;

    // Dès qu'on a un lien valide entre le client et notre serveur...
    io.sockets.on("connection", function (socket) {

        // ...rester à l'écoute de la demande `server-render`...
        socket.on("server-render", function (data) {
            var sessionID = socket.request.sessionID,
                session = socket.request.session,
                locals = {};

            // On récupère les variations spécifiques dans la bonne langue.
            locals = NA.specific("index.json", data.lang, locals);

            // On récupère les variations communes dans la bonne langue.
            locals = NA.common(data.lang, locals);

            // On récupère le fragment HTML depuis le dossier `viewsRelativePath` et on applique les variations.
            data.render = NA.view("partials/index.htm", locals);

            // Et on répond à tous les clients avec un jeu de donnée dans data.
            io.sockets.emit("server-render", data);
        });
    });
};</code></pre><p>Quand au côté client, nous utiliserons les fichiers suivant :</p><p><em>assets/javascripts/index.js</em></p><pre><code class="language-js">var html = document.getElementsByTagName("html")[0],
    layout = document.getElementsByClassName("layout")[0];

// On associe sur le bouton l'action de communiquer avec le serveur en cliquant dessus.
function setServerRender() {
    var button = document.getElementsByTagName("button")[0];
    button.addEventListener("click", function () {
        NA.socket.emit("server-render", {
            lang: html.getAttribute("lang")
        });
    });
}

// On affecte l'action au bouton.
setServerRender();

// Quand le serveur répond après notre demande auprès de lui...
NA.socket.on("server-render", function (data) {

    // ...on met à jour le contenu...
    layout.innerHTML = data.render;

    // ...et ré-affectons l'action au bouton du nouveau contenu.
    setServerRender();
});</code></pre><p>Lancer votre projet et rendez-vous à l'adresse <code>http://localhost/</code> dans deux onglets différent, voir même, dans deux navigateurs différent. Vous constaterez alors qu'à chaque clique sur « Mettre à jour », la page se remettra à jour (comme le montre la date courante) sur tous les onglets ouvert.</p><p>Grâce à <code>NA.specific</code>, <code>NA.common</code> et <code>NA.view</code>, il est possible de générer une nouvelle compilation d'une vue et d'une variation commune et spécifique.</p><p>Si <code>data.lang</code> dans notre exemple est de type <code>undefined</code>, alors les fichiers seront cherchés à la racine. Si <code>locals</code> est de type <code>undefined</code> alors un objet contenant uniquement le scope demandé sera renvoyé.</p><p>Note : pour permettre à <code>view</code> d'utiliser le moteur Pug au lieu de celui d'EJS, il faut mettre la valeur <code>locals.pug</code> à <code>true</code> avant d'utiliser <code>NA.common</code> et <code>NA.specific</code>.</p><h3 id="middlewares">Middlewares</h3><p>NodeAtlas repose en partie sur le module npm <a href="http://expressjs.com/">Express</a>. Vous pouvez accéder à l'objet Express d'une instance NodeAtlas par l'intermédiaire de <code>NA#express</code>. Cela vous permet d'ajouter des middlewares Express de la même manière que vous l'auriez fait avec Express seul.</p><p>En ce qui concerne la préconfiguration d'Express avec un webconfig vide, elle est faites ainsi :</p><pre><code class="language-js">NA.express.set("strict routing", true);
/* ... */
NA.express.set("x-powered-by", false);
/* ... */
/* Activation de gzip, deflate et cie. */
NA.express.use(compress());
/* ... */
/* Parse le type d'encryption "x-www-form-urlencoded". */
NA.express.use(bodyParser.urlencoded({ extended: true }));
/* ... */
/* Parse le type d'encryption "application/json". */
NA.express.use(bodyParser.json());
/* ... */
/* Parse les cookies. */
NA.express.use(cookieParser());
/* ... */
/* Gére les cookies de session. */
NA.express.use(session(optionSession));
/* ... */
/* Gére de dossier `assets/` et son accès depuis le domain root ou un sous-dossier. */
NA.express.use(NA.webconfig.urlRelativeSubPath, express.static(path.join(NA.serverPath, NA.webconfig.assetsRelativePath), staticOptions));</code></pre><p>Vous pouvez vous même ajouter des middlewares de plusieurs manière.</p><h4 id="avec-setconfigurations">Avec <code>setConfigurations</code></h4><p>Vous pouvez obtenir l'objet <code>NA#express</code> près à accueillir des middlewares ici dans le point d'ancrage <code>setConfigurations</code>. Cela ajoutera les mécanismes à toutes les routes de votre site.</p><pre><code class="language-js">exports.setConfigurations = function (next) {
    var NA = this;

    // Middleware fait main.
    NA.express.use(function (request, response, next) {
        response.setHeader("X-Frame-Options", "ALLOW-FROM https://www.lesieur.name/");
        next();
    });

    // Middleware ajoutant diverse entête HTTP de sécurisation.
    NA.express.use(require("helmet")());

    next();
};</code></pre><h4 id="avec-le-paramètre-middlewares-des-routes">Avec le paramètre <code>middlewares</code> des Routes</h4><p>Il est également possible de délivrer ses middlewares uniquement pour une seule route. Dans ce cas vous pouvez utilisez le paramètre <code>middlewares</code> comme suit :</p><p><strong>webconfig.json</strong></p><pre><code class="language-js">{
    "middlewaresRelativePath": "middlewares",
    "routes": {
        "/upload-file": {
            "view": "upload.htm",
            "controller": "upload.js",
            "middlewares": "upload.js"
        }
    }
    "_jwt": {
        secret: "AUTH_CLIENT_SECRET",
        audience: "AUTH_CLIENT_ID"
    }
}</code></pre><p>et utiliser le fichier suivant pour autoriser l'envoi de donnée POST encrypté en <code>"multipart/data-form"</code> uniquement si vous êtes authentifié par un token JSON :</p><p><strong>middlewares/upload.js</strong></p><pre><code class="language-js">var multer  = require("multer"),
    jwt = require("express-jwt");

module.exports = function () {
    var NA = this,
        path = NA.modules.path,
        upload = multer({ dest: path.join(NA.serverPath, "uploads") });

    return [
        jwt({
            secret: NA.webconfig._jwt.secret,
            audience: NA.webconfig._jwt.audience
        }),
        upload.single("avatar"),
    ];
};</code></pre><p><em>Note : si</em> <code>middlewaresRelativePath</code> <em>n'est pas présent dans <code>webconfig.json</code>, par défaut le dossier des contrôleurs est bien</em> <code>middlewares</code>. <code>middlewaresRelativePath</code> <em>est donc utile seulement pour changer le nom / chemin du répertoire.</em></p><h4 id="avec-le-paramètre-middlewares-en-global">Avec le paramètre <code>middlewares</code> en Global</h4><p>Il est également possible d'utiliser ce système pour toutes les routes, ainsi le webconfig se présenterait plutôt ainsi :</p><p><strong>webconfig.json</strong></p><pre><code class="language-js">{
    "middlewares": "is-authenticated.js"
    "routes": {
        "/upload-file": {
            "view": "upload.htm",
            "controller": "upload.js"
        }
    }
    "_jwt": {
        secret: "AUTH_CLIENT_SECRET",
        audience: "AUTH_CLIENT_ID"
    }
}</code></pre><p>Avec le fichier :</p><p><strong>middlewares/is-authenticated.js</strong></p><pre><code class="language-js">var jwt = require("express-jwt");

module.exports = function () {
    var NA = this;

    return [
        jwt({
            secret: NA.webconfig._jwt.secret,
            audience: NA.webconfig._jwt.audience
        })
    ];
};</code></pre><h4 id="tableau-de-middlewares">Tableau de <code>middlewares</code></h4><p>Vous pouvez également fournir un tableau vers une liste de fichier de middleware Express que ce soit pour chaque route ou en global :</p><p><strong>webconfig.json</strong></p><pre><code class="language-js">{
    "routes": {
        "/upload-file": {
            "view": "upload.htm",
            "controller": "upload.js",
            "middlewares": ["is-authenticated.js", "redirect.js"]
        }
    }
    "_jwt": {
        secret: "AUTH_CLIENT_SECRET",
        audience: "AUTH_CLIENT_ID"
    }
}</code></pre><p>Avec l'utilisation de l'objet <code>NA</code> :</p><p><strong>middlewares/is-authenticated.js</strong></p><pre><code class="language-js">var jwt = require("express-jwt");

module.exports = function () {
    var NA = this;

    return [jwt({
        secret: NA.webconfig._jwt.secret,
        audience: NA.webconfig._jwt.audience
    })];
};</code></pre><p>ou sans :</p><p><strong>middlewares/redirect.js</strong></p><pre><code class="language-js">module.exports = function (request, response, next) {

    response.redirect('https://go.to.visitor.page/');

    next();
};</code></pre><div><div class="before">
							<a href="partie-vue.html">◄ Partie vue</a>
						</div><div class="after">
							<a href="partie-outils.html">Partie outils ►</a>
						</div></div>